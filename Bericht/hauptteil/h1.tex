\chapter{Hauptteil}
In diesem Kapitel werden zwei Ansätze zur markerlosen Pose-Erfassung
untersucht und miteinander verglichen: zum einen einen eigenen Workflow mit MediaPipe als Ansatz zur
2D- und 3D- Poseschätzung sowie zum anderen einen fertigen Open Source Workflow für OpenSim
\cite{pose2sim} (mit Verwendung neuere Modelle wie RTM Pose) zur Rekonstruktion biomechanischer Modelle.
Die Motivation für diesen Vergleich liegt darin begründet, dass beide Varianten im Kern 
denselben algorithmischen Berechnungsschritten folgen, sich jedoch in ihrer systemseitigen Umsetzung unterscheiden. 
Während Pose2Sim als integrierte Lösung fungiert, in der die gesamte Prozesskette bereits implementiert ist, 
führt der in 2.1 betrachtete MediaPipe-Workflow die Einzelschritte sequenziell aus 
und beschränkt sich dabei auf die Nutzung eines monokularen Kameraystems.

Des Weiteren erfolgt ein Genauigkeitsvergleich, bei dem die Pose2Sim-Pipeline als Referenz dient, 
um die Eignung des MediaPipe-Ansatzes für biomechanische Anwendungen zu bewerten. 
Ergänzend wird die Robustheit der Pose2Sim-Pipeline gegenüber Störfaktoren wie Kleidung 
oder unterschiedlichen Beleuchtungsbedingungen analysiert.
\newpage
\section{Ablauf bei der Verwendung von MediaPipe}
Zu Beginn brauchen wir aus unseren 2D Daten, in Form eines Videos von unserer Kamera,
geschätzte 3D-Koordinaten von markanten Punkten am Körper (Keypoints).
Wir haben dabei das BlazePose Modell verwendet welches 31 Keypoints liefert.
\begin{figure}[ht]
    \centering
    \includegraphics[width=\textwidth]{MediaPipe-pose-BlazePose-Topology.jpg}
    \label{fig:BlazePose Topologie} 
\end{figure}

Fokussiert haben wir uns dabei erstmal auf drei Keypoints um eine bessere Übersicht zu behalten.
\begin{itemize}
    \item 11. rechte Schulter
    \item 13. rechter Ellbogen
    \item 15. rechtes Handgelenk
\end{itemize}
\newpage
Unser Ziel ist es, diese drei Keypoints aus MediaPipe BlazePose auf ein Modell in OpenSim zu übersetzen
und ,mithilfe des Inversen Kinematik Tools von OpenSim \cite{opensim_ik}, Gelenkwinkel von einer Bewegung herauszubekommen.
Diese können wir dann mit den Gelenkwinkeln vom Pose2Sim Ansatz vergleichen.
Dafür haben wir zwei unterschiedliche OpenSim Modelle  verwendet:

\begin{itemize}
    \item \texttt{arm26}\cite{opensim_models}-- Ein Standard Modell von OpenSim, welches sich nur auf den rechten Arm konzentriert.
    \item \texttt{Model\_Pose2Sim\_muscles\_flex}\cite{pose2sim_setup} -- Ein Ganzkörper Modell von pose2sim für den besseren Vergleich.
\end{itemize}

Für dieses Ziel sind vier wesentliche Schritte notwendig:
\begin{enumerate}
    \item Erhalten der Daten aus einem Video mithilfe von MediaPipe BlazePose
    \item Erstellen einer Marker Datei für OpenSim
    \item Skalierung 
    \item Inverse Kinematik
\end{enumerate}
Das Ergebnis des Inversen Kinematik Tools von OpenSim ist dann eine Bewegungs Datei (.mot).
In dieser finden wir dann die Gelenkwinkel zu bestimmten Zeitpunkten.

Nun folgt eine Beschreibung des Workflows. \newpage
\subsection{Verwendete Bibliotheken}
Für die weiterverarbeitung der Daten mit Python benötigen wir einige Module in unserem Workflow.
Es werden folgende Versionen der Module für die Verwendung mit Python verwendet:
\begin{itemize}
    \item csv (kommt mit python) 3.12.12 \newline
    Standard-Modul zum Schreiben von Textdateien im "Comma Separated Values" - Format.
    \item math (kommt mit python) 3.12.12 \newline
    Standard-Mathematik-Bibliothek von Python.
    \item cv2 4.12.0.88 (opencv-python) \newline
    Bibliothek für Computer Vision. Ist Notwendig zum lesen der Video Dateien und weiteren Bearbeitung. 
    \item MediaPipe 0.10.21 \newline
    Machine-Learning-Bibliotheken von Google. Wichtig für die Pose Schätzung.
    \item pandas 2.3.3 \newline
    Modul für die Datenanalyse und Tabellenkalkulation. Wichtig für die Umwandlung von CSV in TRC Datei.
    \item numpy 1.26.4 \newline
    Standardbibliothek für mathematische Berechnungen mit Vektoren und Matrizen. Wichtig für die Skalierung.
\end{itemize}
\newpage
\subsection{Anzeigen der Videos}
Unsere erste Funktion gibt uns unsere aufgenommenen Videos mit eingezeichneten Skeletten wieder.
Das ist für einen ersten Überblick interessant, um zu sehen ob MediaPipe Blaze Pose die Position der Keypoints
richtig erkannt hat. Außerdem lässt sich schonmal feststellen wo Probleme bei der Erkennung aufkommen.
Es folgt nun ein Beispiel Frame von der Ausgabe der Funktion.
\begin{figure}[ht]
    \centering
    % Erstes Unter-Bild
    \begin{subfigure}[b]{0.45\textwidth}
        \centering
        \includegraphics[width=\textwidth]{videoframe.png}
        \caption{Ohne Marker-Namen}
        \label{fig:frame_no_names}
    \end{subfigure}
    \hfill % Fügt flexiblen Platz zwischen den Bildern ein
    % Zweites Unter-Bild
    \begin{subfigure}[b]{0.45\textwidth}
        \centering
        \includegraphics[width=\textwidth]{videoframe_names.png}
        \caption{Mit Marker-Namen}
        \label{fig:frame_with_names}
    \end{subfigure}
    
    % Gemeinsame Haupt-Beschriftung
    \caption{Vergleich der Video-Ausgabe aus dem MediaPipe Workflow}
    \label{fig:video_comparison}
\end{figure}
\newpage
\subsection{CSV aus MediaPipe Daten}
Als nächstes haben wir die Daten aus MediaPipe in eine CSV geschrieben um mit dieser dann weiterzuarbeiten.

Als Ausgabe erhält man dann eine CSV Datei mit Positions Informationen welche für die Marker Datei später wichtig sind.
Die generierte CSV-Datei folgt einer strikten Struktur, die dynamisch anhand der definierten Marker-Liste erstellt wird. 
\begin{itemize}
    \item \textbf{Zeile 1:} Metadaten zur Framerate (FPS).
    \item \textbf{Zeile 2 (Header):} Spaltenbeschriftungen. Für jeden Marker $n$ werden automatisch drei Spalten (\texttt{Marker$n$\_X}, \texttt{Marker$n$\_Y}, \texttt{Marker$n$\_Z}) generiert.
    \item \textbf{Zeile 3 ff.:} Die Positionsdaten pro Frame.
\end{itemize}

\begin{lstlisting}[caption={Allgemeine Struktur der Ausgabedatei}, label={lst:csv_generic}]
#FPS,30.0
Frame,Marker1_X,Marker1_Y,Marker1_Z,Marker2_X,Marker2_Y,Marker2_Z
0,0.12,-0.55,0.80,0.45,-0.30,0.12
1,0.13,-0.54,0.81,0.46,-0.31,0.13
2,0.13,-0.54,0.81,0.46,-0.31,0.13
...
\end{lstlisting}
\newpage
\subsection{Skalierung der MediaPipe Daten}
Da MediaPipe die erkannten 3D-Koordinaten in einem normierten Raum zurückgibt, müssen diese Koordinaten
skaliert werden, um sie in OpenSim verwenden zu können. Dabei geht es hauptsächlich darum, die Längen
von Körperteilen korrekt darzustellen und nicht über die frames variieren zu lassen und den Ursprung der
MediaPipe Daten auf den Ursprung von OpenSim zu verschieben.

Für die Ursprungsverschiebung muss ein Marker als Referenz gewählt und dessen Position in OpenSim als
Referenzkoordinate übergeben werden. Dann wird die durchschnittliche Koordinate dieses Markers über die
statische Aufnahme berechnet und der Differenzvektor zu der OpenSim Referenzkoordinate bestimmt. Dieser
Vektor wird dann auf alle MediaPipe Koordinaten addiert, um den Ursprung zu verschieben.

Die Skalierung der Körperteile kann auf verschiedene Arten erfolgen:
\begin{itemize}
    \item \textbf{Skalierung über die durchschnittliche Länge in der statischen Aufnahme:} Hier werden die Körperteile
    einfach auf die durchschnittlichen Längen in der statischen Aufnahme skaliert.
    \item \textbf{Skalierung über eine bekannte Referenzlänge:} Hierbei wird eine bekannte Länge 
    (z.B. die Länge eines Armes) verwendet. Dann wird ein Faktor zwischen dieser und der durchschnittlichen Länge des verwendeten
    Körperteils in der statischen Aufnahme berechnet und anschließend auf alle durchschnittlichen Längen aller Körperteile angewendet,
    um die skalierten Längen zu erhalten.

    Dies ist besonders nützlich, wenn die Person in der Aufnahme eine erhöhte Distanz zur Kamera hat.
\end{itemize}

Um die eigentliche Skalierung durchführen zu können, müssen zuerst die zu skalierenden Körperteile definiert werden.
Für eine saubere Skalierung und um Winkel zwischen den Körperteilen beizubehalten, können die Körperteile in Gruppen
zusammengefasst werden. Jede Gruppe kann aus mehreren verbundenen Körperteilen bestehen, die zusammen skaliert werden.
Im Code gibt es dafür das Array \texttt{limb\_groups}, welches die Indizes der
zu skalierenden Körperteile im \texttt{landmark\_map} dictionary als Tupel übergibt.
Bei einem einfachen Arme Modell, bestehend aus 6 Markern (jeweils Schulter, Ellbogen, Handgelenk), könnte dies wie folgt aussehen:
\begin{verbatim}
idx Marker_name
0   r_shoulder
1   r_elbow
2   r_wrist
3   l_shoulder
4   l_elbow
5   l_wrist


limb_groups = [
    [(0, 1), (1, 2)],
    [(3, 4), (4, 5)]
]
\end{verbatim}

Bei der Skalierung wird für jedes Tupel der zweite Marker an den ersten angepasst, daher ist die Reihenfolge hier entscheidend.
Nach der Verschiebung eines Markers wird ein Verschiebungsvektor aufaddiert, welcher vor der Skalierung des nächsten
Körperteils auch auf den zweiten Marker des Tupels angewendet wird, um die Winkel beizubehalten.

Wenn der entsprechende Parameter in der \texttt{scale} Funktion gesetzt ist, werden die
zu skalierenden Längen einmal vor (Fig. \ref{fig:unscaled_plot}) und nach (Fig. \ref{fig:scaled_plot}) der Skalierung in einem Diagramm dargestellt, um die Skalierung zu überprüfen.
\begin{figure}[htbp]
    \centering
    \begin{subfigure}{0.49\textwidth}
        \includegraphics[width=\textwidth]{img/lengths_before_scaling_s.png}
        \caption{Längen vor Skalierung}
        \label{fig:unscaled_plot}
    \end{subfigure}
    \hfill
    \begin{subfigure}{0.48\textwidth}
        \includegraphics[width=\textwidth]{img/lengths_after_scaling_s.png}
        \caption{Längen nach Skalierung}
        \label{fig:scaled_plot}
    \end{subfigure}

    \begin{subfigure}{0.3\textwidth}
        \centering
        \includegraphics[width=\textwidth]{img/scaling_legend.png}
        \label{fig:scaled_legend}
    \end{subfigure}

    \caption{Skalierungs Diagramme}
\end{figure}

Sind nach der Skalierung noch Abweichungen in den Längen der Körperteile vorhanden, so liegt wahrscheinlich ein
Fehler in der Definition der \texttt{limb\_groups} vor.

\subsection{Marker Datei aus CSV}
\subsection{Verwendung von Marker Datei in OpenSim}
\subsection{Anwendung auf ein Modell in OpenSim}
